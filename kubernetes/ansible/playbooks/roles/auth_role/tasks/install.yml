---
- name: Authorization | Templates list
  set_fact:
    auth_role_templates:
      - { name: namespace, file: auth-namespace.yml, type: ns }
      - { name: configmap, file: auth-configmap.yml, type: cm }

- name: Authorization | Create manifests
  template:
    src: "{{ item.file }}.j2"
    dest: "{{ grayskull_dir }}/{{ item.file }}"
  with_items: "{{ auth_role_templates }}"
  register: auth_role_manifests
  when:
    - inventory_hostname == groups['kube-master'][0]

- name: Authorization | Apply manifests
  kube:
    name: "{{ item.item.name }}"
    namespace: "{{ auth_namespace }}"
    kubectl: "{{ bin_dir }}/kubectl"
    resource: "{{ item.item.type }}"
    filename: "{{ grayskull_dir }}/{{ item.item.file }}"
    state: latest
  with_items: "{{ auth_role_manifests.results }}"
  when:
    - inventory_hostname == groups['kube-master'][0]

- name: Authorization | Create secret/auth directory
  file:
    path: "{{ auth_secrets_dir }}"
    state: directory
    mode: 0755


# TODO: Instead of password file, can use password ansible module
- name: Authorization | Move passwd file
  copy: 
    src: "files/secrets/password"
    dest: "{{ auth_passwd_file }}"
    mode: 0755

# ---- Make Certs

# One of the differences between kubespray and RKE is what they call their certs.
# The next 3 tasks copy the kubespray one to the corresponding name that RKE would use.
# This is especially prudent becasue the certs_role copies files using a naming scheme that is 
# closer to that of RKE. 
- name: Authorization | Check for kube-ca
  stat:
    path: /etc/kubernetes/ssl/kube-ca.pem
  register: kubeca

- name: Authorization | Check for other kube-ca
  stat:
    path: /etc/kubernetes/ssl/ca.crt
  register: cacrt
  when: kubeca.stat is defined and not kubeca.stat.exists

- name: Authorization | Copy kube-ca
  copy:
    src: "/etc/kubernetes/ssl/ca.crt"
    dest: "/etc/kubernetes/ssl/kube-ca.pem"
    remote_src: true
  when: cacrt.stat is defined and cacrt.stat.exists

- name: Authorization | Copy kube-ca-key
  copy:
    src: "/etc/kubernetes/ssl/ca.key"
    dest: "/etc/kubernetes/ssl/kube-ca-key.pem"
    remote_src: true
  when: cacrt.stat is defined and cacrt.stat.exists

- name: Authorization | Make certs
  import_role:
    name: certs_role
  vars:
    # create a ca to sign our certs
    ca_path: "{{ kube_ca_path }}/kube-ca"
    ca_csrjson_src: "{{ grayskull_dir }}/csr.json"
    # create a server, client, and chain cert
    task_create_server: true
    server_path: "{{ grayskull_dir }}/auth-server"
    server_client_path: "{{ grayskull_dir }}/auth-client"
    server_chain_path: "{{ grayskull_dir }}/auth-chain"
    # copy the certs to name them as the k8s secret expects
    task_copy: true
    copy_ca_path: "{{ grayskull_dir }}/cacerts.pem"
    copy_server_key_path: "{{ auth_secrets_dir }}/tls.key"
    copy_chain_path: "{{ auth_secrets_dir }}/tls.crt"

#---- Create secret

- name: Authorization | Check for secret
  shell: "{{ bin_dir }}/kubectl get secrets -n {{ auth_namespace }}"
  register: auth_secret_exists
  changed_when: false

- name: Authorization | Create secret
  shell: "{{ bin_dir }}/kubectl create secret generic {{ ingress_secretName }} --from-file {{ auth_secrets_dir }}/tls.crt --from-file {{ auth_secrets_dir }}/tls.key --from-file ca.crt={{ kube_ca_path }}/kube-ca.pem -n {{ auth_namespace }}"
  when: "ingress_secretName not in auth_secret_exists.stdout"

- name: Authorization | Create pass secret
  shell: "{{ bin_dir }}/kubectl create secret generic {{ auth_passwd_secretName }} --from-file {{ auth_passwd_file }} -n {{ auth_namespace }}"
  when: "auth_passwd_secretName not in auth_secret_exists.stdout"

- name: Authorization | Deploy chart
  helm_chart:
    name: "{{ helm_auth_chart_name }}"
    namespace: "{{ auth_namespace }}"
    bin_dir: "{{ bin_dir }}"
    chart_src: "{{ grayskull_dir }}/{{ helm_auth_image_name }}"
    chart_version: "{{ helm_auth_chart_version }}"
    path_to_values: "{{ grayskull_dir }}/customizations/keycloak.yml"
