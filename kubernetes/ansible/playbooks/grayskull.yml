---
# - import_playbook: kubespray/cluster.yml

- hosts: kube-setup-delegate
  become: yes
  tasks:

  #---- Helm and Kubectl set up
  - name: Setup | Export KUBECONFIG env var
    lineinfile:
      path: /etc/profile
      line: export KUBECONFIG=/etc/kubernetes/admin.conf
      create: yes

  - name: Setup | Create grayskull directory
    file:
      path: "{{ grayskull_dir }}"
      state: directory
      mode: '0755'

  - name: Setup | Copy over Tiller RBAC
    copy:
      src: tiller-rbac.yml
      dest: "{{ grayskull_dir }}/tiller-rbac.yml"

  - name: Setup | Apply Tiller RBAC definition
    kube:
      name: tiller-rbac
      namespace: kube-system
      kubectl: "{{ bin_dir }}/kubectl"
      filename: "{{ grayskull_dir }}/tiller-rbac.yml"
      state: present

  # Needed to re-install helm if the remove playbook is run. 
  - name: Setup | Retrieve helm binary archive
    unarchive:
      src: https://storage.googleapis.com/kubernetes-helm/helm-v2.14.3-linux-amd64.tar.gz
      dest: "{{ bin_dir }}"
      remote_src: yes
      exclude:
        - "*/LICENSE"
        - "*/README.md"
        - "*/tiller"
      extra_opts:
        - --strip-components=1

  - name: Setup | Move helm binary into place
    command: >
      cp /tmp/linux-amd64/helm {{ bin_dir }}
      creates={{ bin_dir }}/helm

  - name: Setup | Set up Helm and Tiller
    command: "{{ bin_dir }}/helm init --service-account tiller"
    register: helm_init_result
    changed_when: "'already installed' not in helm_init_result.stdout"

  - name: Setup | Update Helm repos
    command: "{{ bin_dir }}/helm repo update"

  # ---- Make Certificates
  - include: certificate-tasks.yml

  # ---- Copy Customizations to remote
  - name: Customization Files | Create list
    set_fact:
      customizations_files:
        - { file: customizations/ceph.yml }
        - { file: customizations/dash-proxy.yml }
        - { file: customizations/keycloak.yml }
        - { file: customizations/nginx-ingress.yml }
        - { file: customizations/prometheus.yml }
        - { file: customizations/elasticsearch.yml }
        - { file: customizations/kibana.yml }
        - { file: customizations/logstash.yml }
        - { file: customizations/fluentd.yml }
        - { file: customizations/registry.yml }

  - name: Customization Files | Create customizations directory
    file:
      path: "{{ grayskull_dir }}/customizations"
      state: directory
      mode: '0755'

  - name: Customization Files | Move to kube-master
    template:
      src: "{{ item.file }}"
      dest: "{{ grayskull_dir }}/{{ item.file }}"
    with_items: "{{ customizations_files }}"


  #---- Generate or reuse UUID
  - include: uuid-tasks.yml

- hosts: kube-setup-delegate
  become: yes
  # Turns out vars are shared for all instances of a role. You must explicitly define each variable for each role. The default value doesn't matter if its overridden anywhere.
  roles:
    - { role: ingress_role, when: (ingress_role_enabled | default(True)) }
    - { role: prometheus_role, when: (prometheus_role_enabled | default(True)) }   # must be deployed before rook-ceph
    - { role: rook_ceph_role, when: (rook_ceph_role_enabled | default(True)) }
    - { role: rook_cassandra_role, when: (rook_cassandra_role_enabled | default(True)) }
    - { role: registry_role, when: (registry_role_enabled | default(True)) }
    - { role: auth_role, when: (auth_role_enabled | default(True)) }
    - { role: dashboard_role, when: (dashboard_role_enabled | default(True)) }
    - { role: dash_proxy_role, when: (dash_proxy_role_enabled | default(True)) }
    - { role: elk_role, when: (elk_role_enabled | default(True)) }
    - { role: ion_role, vars: { ms_name: "cdr", ms_namespace: "cdr", is_cluster_admin: false }, when: (ion_role_enabled | default(True)) }
    - { role: ion_role, vars: { ms_name: "transform", ms_namespace: "transform", is_cluster_admin: false }, when: (ion_role_enabled | default(True)) }
    - { role: ion_role, vars: { ms_name: "replication", ms_namespace: "replication", is_cluster_admin: false }, when: (ion_role_enabled | default(True)) }
    - { role: ion_role, vars: { ms_name: "platform", ms_namespace: "platform", is_cluster_admin: true }, when: (ion_role_enabled | default(True)) }
    - { role: ion_role, vars: { ms_name: "security", ms_namespace: "security", is_cluster_admin: true }, when: (ion_role_enabled | default(True)) }
