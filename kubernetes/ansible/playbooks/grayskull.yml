---
# This playbook sets up the platform services that make up the grayskull platform.
# This playbook assumes that the ansible host 'kube-setup-delegate' is capable of reaching
# an already provisioned kubernetes cluster. It will install kubectl if necessary,
# but you must provide it a path to a valid KUBECONFIG using the variable kubeconfig_src.

# - import_playbook: kubespray/cluster.yml

# TODO: There is probably a better place for vars. Group vars? The inventory?
- hosts: kube-setup-delegate
  become: yes
  vars:
    kubeconfig_src: "../kube_config_stage4.yml"
  tasks:

  #---- Helm and Kubectl set up
    - name: Setup | Test kubectl
      shell: "which kubectl"
      register: kubectl_result
      ignore_errors: True

    - name: Setup | install kubectl
      get_url: 
        url: https://storage.googleapis.com/kubernetes-release/release/v1.16.1/bin/linux/amd64/kubectl
        dest: "/usr/bin/kubectl"
        mode: '0755'
      when: kubectl_result.rc != 0

    - name: Setup | Copy kubeconfig 
      copy:
        src: "{{ kubeconfig_src }}"
        dest: "/etc/kubernetes/admin.conf"

    # doesn't immediately work but is more permanent(?)
    - name: Setup | Export KUBECONFIG env var
      lineinfile:
        path: /etc/profile
        line: export KUBECONFIG=/etc/kubernetes/admin.conf
        create: yes

    - name: Add env var
      lineinfile:
        path: /etc/environment
        regexp: 'KUBECONFIG=*'
        line: KUBECONFIG=/etc/kubernetes/admin.conf

    - name: Setup | Create grayskull directory
      file:
        path: "{{ grayskull_dir }}"
        state: directory
        mode: '0755'

    - name: Setup | Copy over Tiller RBAC
      copy:
        src: tiller-rbac.yml
        dest: "{{ grayskull_dir }}/tiller-rbac.yml"

    - name: Setup | Apply Tiller RBAC definition
      kube:
        name: tiller-rbac
        namespace: kube-system
        kubectl: "{{ bin_dir }}/kubectl"
        filename: "{{ grayskull_dir }}/tiller-rbac.yml"
        state: present

  # Needed to re-install helm if the remove playbook is run. 
    - name: Setup | Retrieve helm binary archive
      unarchive:
        src: https://storage.googleapis.com/kubernetes-helm/helm-v2.14.3-linux-amd64.tar.gz
        dest: "{{ bin_dir }}"
        remote_src: yes
        exclude:
          - "*/LICENSE"
          - "*/README.md"
          - "*/tiller"
        extra_opts:
          - --strip-components=1

    - name: Setup | Move helm binary into place
      command: >
        cp /tmp/linux-amd64/helm {{ bin_dir }}
        creates={{ bin_dir }}/helm

    - name: Setup | Set up Helm and Tiller
      command: "{{ bin_dir }}/helm init --service-account tiller"
      register: helm_init_result
      changed_when: "'already installed' not in helm_init_result.stdout"

    - name: Rancher | Wait for tiller to rollout
      shell: "kubectl -n kube-system rollout status deploy/tiller-deploy"

    - name: Setup | Update Helm repos
      command: "{{ bin_dir }}/helm repo update"

    - name: Certificate Tasks | Create grayskull/secrets directory
      file:
        path: "{{ grayskull_dir }}/secrets"
        state: directory
        mode: '0755'

    # Template json
    - name: Certificate Tasks | Templates list
      set_fact:
        service_role_templates:
          - { name: csr.json, file: "csr.json.tpl" }

    - name: Certificate Tasks | Create manifests
      template:
        src: "{{ item.file }}"
        dest: "csr.json"
      with_items: "{{ service_role_templates }}"

    - name: Certificate Tasks | Copy over csr
      copy:
        src: csr.json
        dest: "{{ grayskull_dir }}/csr.json"


    # ---- Make Certificates
- hosts: kube-setup-delegate
  become: yes
  vars: 
    path: "certs"
  roles:
    - role: certs_role
      vars:
        # create a ca to sign our certs
        task_create_ca: true
        ca_path: "{{ grayskull_dir }}/ca"
        ca_csrjson_src: "{{ grayskull_dir }}/csr.json"
        # create a server, client, and chain cert
        task_create_server: true
        server_path: "{{ grayskull_dir }}/server"
        server_client_path: "{{ grayskull_dir }}/client"
        server_chain_path: "{{ grayskull_dir }}/chain"
        # copy the certs to name them as the k8s secret expects
        task_copy: true
        copy_ca_path: "{{ grayskull_dir }}/cacerts.pem"
        copy_server_key_path: "{{ grayskull_dir }}/secrets/tls.key"
        copy_chain_path: "{{ grayskull_dir }}/secrets/tls.crt"

- hosts: kube-setup-delegate
  become: yes
  tasks:
    # ---- Copy Customizations to remote
    - name: Customization Files | Create list
      set_fact:
        customizations_files:
          - { file: customizations/ceph.yml }
          - { file: customizations/dash-proxy.yml }
          - { file: customizations/keycloak.yml }
          - { file: customizations/nginx-ingress.yml }
          - { file: customizations/prometheus.yml }
          - { file: customizations/elasticsearch.yml }
          - { file: customizations/kibana.yml }
          - { file: customizations/logstash.yml }
          - { file: customizations/fluentd.yml }

    - name: Customization Files | Create customizations directory
      file:
        path: "{{ grayskull_dir }}/customizations"
        state: directory
        mode: '0755'

    - name: Customization Files | Move to kube-master
      copy:
        src: "{{ item.file }}"
        dest: "{{ grayskull_dir }}/{{ item.file }}"
      with_items: "{{ customizations_files }}"


  #---- Generate or reuse UUID
    - name: UUID-tasks
      include: uuid-tasks.yml

- hosts: kube-setup-delegate
  become: yes
  # Turns out vars are shared for all instances of a role. You must explicitly define each variable for each role. The default value doesn't matter if its overridden anywhere.
  roles:
    - { role: ingress_role, when: (ingress_role_enabled | default(True)) }
    - { role: prometheus_role, when: (prometheus_role_enabled | default(True)) }   # must be deployed before rook-ceph
    - { role: rook_ceph_role, when: (rook_ceph_role_enabled | default(True)) }
    - { role: rook_cassandra_role, when: (rook_cassandra_role_enabled | default(True)) }
    - { role: auth_role, when: (auth_role_enabled | default(True)) }
    - { role: dashboard_role, when: (dashboard_role_enabled | default(True)) }
    - { role: dash_proxy_role, when: (dash_proxy_role_enabled | default(True)) }
    - { role: elk_role, when: (elk_role_enabled | default(True)) }
    - { role: ion_role, when: (ion_role_enabled | default(True)),  
        vars: { 
          ms_name: "cdr", 
          ms_namespace: "cdr", 
          is_cluster_admin: false 
        } 
      }
    - { role: ion_role, when: (ion_role_enabled | default(True)),
        vars: { 
          ms_name: "transform", 
          ms_namespace: "transform", 
          is_cluster_admin: false 
        } 
      }
    - { role: ion_role, when: (ion_role_enabled | default(True)),
        vars: { 
          ms_name: "replication", 
          ms_namespace: "replication", 
          is_cluster_admin: false 
        }
      }
    - { role: ion_role, when: (ion_role_enabled | default(True)),
        vars: { 
          ms_name: "platform", 
          ms_namespace: "platform", 
          is_cluster_admin: true 
        } 
      }
    - { role: ion_role,  when: (ion_role_enabled | default(True)),
        vars: { 
          ms_name: "security", 
          ms_namespace: "security", 
          is_cluster_admin: true 
        }
      }
